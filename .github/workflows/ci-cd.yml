# name: CI/CD Pipeline

# on:
#   push:
#     branches: [ main, develop ]
#   pull_request:
#     branches: [ main ]

# env:
#   NODE_VERSION: '18'
#   DOCKER_REGISTRY: 'your-registry.com'
#   APP_NAME: 'lead-management-system'

# jobs:
#   test:
#     name: Run Tests
#     runs-on: ubuntu-latest
    
#     services:
#       postgres:
#         image: postgres:15
#         env:
#           POSTGRES_PASSWORD: postgres
#           POSTGRES_DB: lead_management_test
#         options: >-
#           --health-cmd pg_isready
#           --health-interval 10s
#           --health-timeout 5s
#           --health-retries 5
#         ports:
#           - 5432:5432
      
#       redis:
#         image: redis:7
#         options: >-
#           --health-cmd "redis-cli ping"
#           --health-interval 10s
#           --health-timeout 5s
#           --health-retries 5
#         ports:
#           - 6379:6379

#     steps:
#     - name: Checkout code
#       uses: actions/checkout@v4

#     - name: Setup Node.js
#       uses: actions/setup-node@v4
#       with:
#         node-version: ${{ env.NODE_VERSION }}
#         cache: 'npm'

#     - name: Install dependencies
#       run: |
#         npm ci
#         cd backend && npm ci
#         cd ../frontend && npm ci

#     - name: Run linting
#       run: |
#         cd backend && npm run lint
#         cd ../frontend && npm run lint

#     - name: Run backend tests
#       env:
#         NODE_ENV: test
#         DATABASE_URL: postgresql://postgres:postgres@localhost:5432/lead_management_test
#         REDIS_URL: redis://localhost:6379
#       run: |
#         cd backend
#         npm run test:unit
#         npm run test:integration

#     - name: Run frontend tests
#       run: |
#         cd frontend
#         npm run test

#     - name: Run E2E tests
#       env:
#         NODE_ENV: test
#         DATABASE_URL: postgresql://postgres:postgres@localhost:5432/lead_management_test
#         REDIS_URL: redis://localhost:6379
#       run: |
#         cd backend && npm run dev &
#         cd frontend && npm run dev &
#         sleep 30
#         cd frontend && npm run test:e2e

#     - name: Generate test coverage
#       run: |
#         cd backend && npm run test:coverage
#         cd ../frontend && npm run test:coverage

#     - name: Upload coverage to Codecov
#       uses: codecov/codecov-action@v3
#       with:
#         directory: ./coverage

#   security-scan:
#     name: Security Scan
#     runs-on: ubuntu-latest
    
#     steps:
#     - name: Checkout code
#       uses: actions/checkout@v4

#     - name: Run npm audit
#       run: |
#         cd backend && npm audit --audit-level moderate
#         cd ../frontend && npm audit --audit-level moderate

#     - name: Run Snyk security scan
#       uses: snyk/actions/node@master
#       env:
#         SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
#       with:
#         args: --severity-threshold=high

#   build:
#     name: Build Application
#     runs-on: ubuntu-latest
#     needs: [test, security-scan]
    
#     steps:
#     - name: Checkout code
#       uses: actions/checkout@v4

#     - name: Setup Node.js
#       uses: actions/setup-node@v4
#       with:
#         node-version: ${{ env.NODE_VERSION }}
#         cache: 'npm'

#     - name: Install dependencies
#       run: |
#         npm ci
#         cd backend && npm ci
#         cd ../frontend && npm ci

#     - name: Build backend
#       run: |
#         cd backend
#         npm run build

#     - name: Build frontend
#       run: |
#         cd frontend
#         npm run build

#     - name: Set up Docker Buildx
#       uses: docker/setup-buildx-action@v3

#     - name: Login to Docker Registry
#       uses: docker/login-action@v3
#       with:
#         registry: ${{ env.DOCKER_REGISTRY }}
#         username: ${{ secrets.DOCKER_USERNAME }}
#         password: ${{ secrets.DOCKER_PASSWORD }}

#     - name: Build and push backend Docker image
#       uses: docker/build-push-action@v5
#       with:
#         context: ./backend
#         file: ./backend/Dockerfile
#         push: true
#         tags: |
#           ${{ env.DOCKER_REGISTRY }}/${{ env.APP_NAME }}-backend:${{ github.sha }}
#           ${{ env.DOCKER_REGISTRY }}/${{ env.APP_NAME }}-backend:latest
#         cache-from: type=gha
#         cache-to: type=gha,mode=max

#     - name: Build and push frontend Docker image
#       uses: docker/build-push-action@v5
#       with:
#         context: ./frontend
#         file: ./frontend/Dockerfile
#         push: true
#         tags: |
#           ${{ env.DOCKER_REGISTRY }}/${{ env.APP_NAME }}-frontend:${{ github.sha }}
#           ${{ env.DOCKER_REGISTRY }}/${{ env.APP_NAME }}-frontend:latest
#         cache-from: type=gha
#         cache-to: type=gha,mode=max

#   deploy-staging:
#     name: Deploy to Staging
#     runs-on: ubuntu-latest
#     needs: build
#     if: github.ref == 'refs/heads/develop'
#     environment: staging
    
#     steps:
#     - name: Checkout code
#       uses: actions/checkout@v4

#     - name: Deploy to staging
#       run: |
#         echo "Deploying to staging environment..."
#         # Add your staging deployment commands here
#         # Examples:
#         # - kubectl apply -f k8s/staging/
#         # - helm upgrade --install app-staging ./helm-chart
#         # - docker-compose -f docker-compose.staging.yml up -d

#     - name: Run smoke tests
#       run: |
#         echo "Running smoke tests against staging..."
#         # Add smoke test commands here
#         # curl -f https://staging.yourapp.com/health || exit 1

#     - name: Notify deployment
#       uses: 8398a7/action-slack@v3
#       with:
#         status: ${{ job.status }}
#         channel: '#deployments'
#         webhook_url: ${{ secrets.SLACK_WEBHOOK }}
#       if: always()

#   deploy-production:
#     name: Deploy to Production
#     runs-on: ubuntu-latest
#     needs: build
#     if: github.ref == 'refs/heads/main'
#     environment: production
    
#     steps:
#     - name: Checkout code
#       uses: actions/checkout@v4

#     - name: Deploy to production
#       run: |
#         echo "Deploying to production environment..."
#         # Add your production deployment commands here
#         # Examples:
#         # - kubectl apply -f k8s/production/
#         # - helm upgrade --install app-prod ./helm-chart
#         # - Blue-green deployment script

#     - name: Run health checks
#       run: |
#         echo "Running health checks..."
#         # Wait for deployment to be ready
#         sleep 60
#         # Check health endpoint
#         curl -f https://api.yourapp.com/health || exit 1

#     - name: Run production smoke tests
#       run: |
#         echo "Running production smoke tests..."
#         # Add production smoke tests here

#     - name: Notify deployment
#       uses: 8398a7/action-slack@v3
#       with:
#         status: ${{ job.status }}
#         channel: '#deployments'
#         webhook_url: ${{ secrets.SLACK_WEBHOOK }}
#       if: always()

#   rollback:
#     name: Rollback Production
#     runs-on: ubuntu-latest
#     if: failure() && github.ref == 'refs/heads/main'
#     needs: deploy-production
#     environment: production
    
#     steps:
#     - name: Rollback deployment
#       run: |
#         echo "Rolling back production deployment..."
#         # Add rollback commands here
#         # Examples:
#         # - kubectl rollout undo deployment/app
#         # - helm rollback app-prod
        
#     - name: Verify rollback
#       run: |
#         echo "Verifying rollback..."
#         curl -f https://api.yourapp.com/health || exit 1

#     - name: Notify rollback
#       uses: 8398a7/action-slack@v3
#       with:
#         status: 'rollback'
#         channel: '#alerts'
#         webhook_url: ${{ secrets.SLACK_WEBHOOK }}